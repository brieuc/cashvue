/**
 * Generated by orval v7.13.2 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import { customFetch } from './fetch-instance';

// https://stackoverflow.com/questions/49579094/typescript-conditional-types-filter-out-readonly-properties-pick-only-requir/49579497#49579497
type IfEquals<X, Y, A = X, B = never> = (<T>() => T extends X ? 1 : 2) extends <
T,
>() => T extends Y ? 1 : 2
? A
: B;

type WritableKeys<T> = {
[P in keyof T]-?: IfEquals<
  { [Q in P]: T[P] },
  { -readonly [Q in P]: T[P] },
  P
>;
}[keyof T];

type UnionToIntersection<U> =
  (U extends any ? (k: U)=>void : never) extends ((k: infer I)=>void) ? I : never;
type DistributeReadOnlyOverUnions<T> = T extends any ? NonReadonly<T> : never;

type Writable<T> = Pick<T, WritableKeys<T>>;
type NonReadonly<T> = [T] extends [UnionToIntersection<T>] ? {
  [P in keyof Writable<T>]: T[P] extends object
    ? NonReadonly<NonNullable<T[P]>>
    : T[P];
} : DistributeReadOnlyOverUnions<T>;

/**
 * Represents a tag/label for categorizing entries
 */
export type TagDto = {
  /** Unique identifier of the tag */
  id?: number;
  /**
   * Name/title of the tag
   * @maxLength 100
   */
  title: string;
  /**
   * Detailed description of the tag
   * @maxLength 500
   */
  description?: string;
  /**
   * Icon associated with the tag (emoji or code)
   * @maxLength 50
   */
  icon?: string;
  /**
   * Sort order for display
   * @minimum 0
   */
  sortingOrder?: number;
  /**
   * ISO 4217 currency code (3 letters)
   * @minLength 3
   * @maxLength 3
   */
  currencyCode: string;
  /** Whether the tag represents cumulative values */
  isCumulative?: boolean;
  /** Whether the tag is hidden from display */
  hidden?: boolean;
};

/**
 * Represents an exchange rate between two currencies
 */
export type RateDto = {
  /** Unique identifier of the exchange rate */
  readonly id?: number;
  /**
   * ISO 4217 code of the source currency
   * @minLength 3
   * @maxLength 3
   */
  sourceCurrencyCode: string;
  /**
   * ISO 4217 code of the target currency (reference currency)
   * @minLength 3
   * @maxLength 3
   */
  targetCurrencyCode: string;
  /** Validity date of the exchange rate */
  valueDate: string;
  /** Exchange rate value (1 unit of source = rate units of target) */
  rate: number;
};

/**
 * Represents a defined time period
 */
export type PeriodDto = {
  /** Unique identifier of the period */
  readonly id?: number;
  /**
   * Title or name of the period
   * @maxLength 255
   */
  title: string;
  /** Start date and time of the period */
  startDate: string;
  /** End date and time of the period */
  endDate: string;
  /**
   * ISO 4217 currency code (3 letters)
   * @minLength 3
   * @maxLength 3
   */
  currencyCode: string;
  /** Whether the period is hidden from display */
  hidden?: boolean;
};

/**
 * Represents a financial entry (transaction)
 */
export type EntryDto = {
  /** Unique identifier of the entry */
  id?: number;
  /** Accounting date of the transaction */
  accountingDate: string;
  /** Last modification date (managed automatically) */
  readonly modificationDate?: string;
  /**
   * Title or label of the entry
   * @maxLength 255
   */
  title: string;
  /**
   * Detailed description of the transaction
   * @maxLength 1000
   */
  description?: string;
  /** Transaction amount (positive for credit, negative for debit) */
  amount: number;
  /**
   * ISO 4217 currency code (3 letters)
   * @minLength 3
   * @maxLength 3
   */
  currencyCode: string;
  /** List of tags/labels associated with this entry */
  tags?: TagDto[];
};

/**
 * Represents a monetary currency
 */
export type CurrencyDto = {
  /**
   * ISO 4217 currency code (3 uppercase letters)
   * @minLength 3
   * @maxLength 3
   */
  code: string;
  /** Whether this currency is the reference currency */
  reference?: boolean;
};

/**
 * Request for aggregated amount calculation over a period
 */
export type ComputationRequestDto = {
  /** Start date of the calculation period */
  startDate: string;
  /** End date of the calculation period */
  endDate: string;
  /** List of tags to filter entries in the calculation */
  tags?: TagDto[];
  /**
   * ISO 4217 code of the target currency for conversion (reference currency or tag currency)
   * @minLength 3
   * @maxLength 3
   */
  targetCurrencyCode: string;
};

/**
 * Breakdown of aggregated calculation for a specific currency
 */
export type ComputationCurrencyAmountDto = {
  /** ISO 4217 currency code */
  currencyCode?: string;
  /** Number of entries in this currency */
  numberOfEntries?: number;
  /** Total amount in this currency (before conversion) */
  totalAmount?: number;
};

/**
 * Breakdown of calculations by source currency (key = currency code, value = calculation details)
 */
export type ComputationResponseDtoComputationByCurrency = {[key: string]: ComputationCurrencyAmountDto};

/**
 * Result of aggregated amount calculation
 */
export type ComputationResponseDto = {
  /** Start date of the calculated period */
  startDate?: string;
  /** End date of the calculated period */
  endDate?: string;
  /** Total amount converted to the target currency */
  totalAmount?: number;
  /** ISO 4217 code of the target currency used for conversion */
  targetCurrencyCode?: string;
  /** Total number of entries included in the calculation */
  numberOfEntries?: number;
  /** Breakdown of calculations by source currency (key = currency code, value = calculation details) */
  computationByCurrency?: ComputationResponseDtoComputationByCurrency;
};

export type PageImplTagDto = {
  content?: TagDto[];
  pageable?: PageableObject;
  totalElements?: number;
  totalPages?: number;
  last?: boolean;
  numberOfElements?: number;
  first?: boolean;
  size?: number;
  number?: number;
  sort?: SortObject;
  empty?: boolean;
};

export type PageableObject = {
  unpaged?: boolean;
  paged?: boolean;
  pageNumber?: number;
  pageSize?: number;
  offset?: number;
  sort?: SortObject;
};

export type SortObject = {
  unsorted?: boolean;
  sorted?: boolean;
  empty?: boolean;
};

export type PageImplRateDto = {
  content?: RateDto[];
  pageable?: PageableObject;
  totalElements?: number;
  totalPages?: number;
  last?: boolean;
  numberOfElements?: number;
  first?: boolean;
  size?: number;
  number?: number;
  sort?: SortObject;
  empty?: boolean;
};

export type PageImplPeriodDto = {
  content?: PeriodDto[];
  pageable?: PageableObject;
  totalElements?: number;
  totalPages?: number;
  last?: boolean;
  numberOfElements?: number;
  first?: boolean;
  size?: number;
  number?: number;
  sort?: SortObject;
  empty?: boolean;
};

export type PageImplEntryDto = {
  content?: EntryDto[];
  pageable?: PageableObject;
  totalElements?: number;
  totalPages?: number;
  last?: boolean;
  numberOfElements?: number;
  first?: boolean;
  size?: number;
  number?: number;
  sort?: SortObject;
  empty?: boolean;
};

export type PageImplCurrencyDto = {
  content?: CurrencyDto[];
  pageable?: PageableObject;
  totalElements?: number;
  totalPages?: number;
  last?: boolean;
  numberOfElements?: number;
  first?: boolean;
  size?: number;
  number?: number;
  sort?: SortObject;
  empty?: boolean;
};

export type GetTagsParams = {
/**
 * Page number (starts at 0)
 * @minimum 0
 * @maximum 2147483647
 */
page?: number;
/**
 * Number of elements per page
 * @minimum 1
 * @maximum 1000
 */
size?: number;
/**
 * Sort criteria (format: 'property:direction' where direction = asc|desc)
 */
sort?: string[];
};

export type GetRatesParams = {
/**
 * Page number (starts at 0)
 * @minimum 0
 * @maximum 2147483647
 */
page?: number;
/**
 * Number of elements per page
 * @minimum 1
 * @maximum 1000
 */
size?: number;
/**
 * Sort criteria (format: 'property:direction' where direction = asc|desc)
 */
sort?: string[];
};

export type GetPeriodsParams = {
/**
 * Page number (starts at 0)
 * @minimum 0
 * @maximum 2147483647
 */
page?: number;
/**
 * Number of elements per page
 * @minimum 1
 * @maximum 1000
 */
size?: number;
/**
 * Sort criteria (format: 'property:direction' where direction = asc|desc)
 */
sort?: string[];
};

export type GetEntriesParams = {
/**
 * Start date of the search period (inclusive, will use start of day)
 */
startDate?: string;
/**
 * End date of the search period (inclusive, will use end of day)
 */
endDate?: string;
/**
 * List of tag IDs to filter entries
 */
tagIds?: number[];
/**
 * Minimum transaction amount
 */
startAmount?: number;
/**
 * Maximum transaction amount
 */
endAmount?: number;
/**
 * Currency codes to filter entries (ISO 4217 codes)
 */
currencyCodes?: string[];
/**
 * Page number (starts at 0)
 * @minimum 0
 * @maximum 2147483647
 */
page?: number;
/**
 * Number of elements per page
 * @minimum 1
 * @maximum 1000
 */
size?: number;
/**
 * Sort criteria (format: 'property:direction' where direction = asc|desc)
 */
sort?: string[];
};

export type GetCurrenciesParams = {
/**
 * Page number (starts at 0)
 * @minimum 0
 * @maximum 2147483647
 */
page?: number;
/**
 * Number of elements per page
 * @minimum 1
 * @maximum 1000
 */
size?: number;
/**
 * Sort criteria (format: 'property:direction' where direction = asc|desc)
 */
sort?: string[];
};

export type GetRatesByCurrencyParams = {
/**
 * Page number (starts at 0)
 * @minimum 0
 * @maximum 2147483647
 */
page?: number;
/**
 * Number of elements per page
 * @minimum 1
 * @maximum 1000
 */
size?: number;
/**
 * Sort criteria (format: 'property:direction' where direction = asc|desc)
 */
sort?: string[];
};

export type GetPeriodByDateParams = {
/**
 * Date √† rechercher
 */
date: string;
};

/**
 * Retourne un tag sp√©cifique
 * @summary R√©cup√©rer un tag par son ID
 */
export type getTagByIdResponse200 = {
  data: TagDto
  status: 200
}

export type getTagByIdResponse404 = {
  data: void
  status: 404
}
    
export type getTagByIdResponseSuccess = (getTagByIdResponse200) & {
  headers: Headers;
};
export type getTagByIdResponseError = (getTagByIdResponse404) & {
  headers: Headers;
};

export type getTagByIdResponse = (getTagByIdResponseSuccess | getTagByIdResponseError)

export const getGetTagByIdUrl = (id: number,) => {


  

  return `/tags/${id}`
}

export const getTagById = async (id: number, options?: RequestInit): Promise<getTagByIdResponse> => {
  
  return customFetch<getTagByIdResponse>(getGetTagByIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Met √† jour un tag existant
 * @summary Mettre √† jour un tag
 */
export type updateTagResponse200 = {
  data: TagDto
  status: 200
}

export type updateTagResponse400 = {
  data: void
  status: 400
}

export type updateTagResponse404 = {
  data: void
  status: 404
}
    
export type updateTagResponseSuccess = (updateTagResponse200) & {
  headers: Headers;
};
export type updateTagResponseError = (updateTagResponse400 | updateTagResponse404) & {
  headers: Headers;
};

export type updateTagResponse = (updateTagResponseSuccess | updateTagResponseError)

export const getUpdateTagUrl = (id: number,) => {


  

  return `/tags/${id}`
}

export const updateTag = async (id: number,
    tagDto: TagDto, options?: RequestInit): Promise<updateTagResponse> => {
  
  return customFetch<updateTagResponse>(getUpdateTagUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tagDto,)
  }
);}



/**
 * Supprime un tag d√©finitivement
 * @summary Supprimer un tag
 */
export type deleteTagResponse204 = {
  data: void
  status: 204
}

export type deleteTagResponse404 = {
  data: void
  status: 404
}
    
export type deleteTagResponseSuccess = (deleteTagResponse204) & {
  headers: Headers;
};
export type deleteTagResponseError = (deleteTagResponse404) & {
  headers: Headers;
};

export type deleteTagResponse = (deleteTagResponseSuccess | deleteTagResponseError)

export const getDeleteTagUrl = (id: number,) => {


  

  return `/tags/${id}`
}

export const deleteTag = async (id: number, options?: RequestInit): Promise<deleteTagResponse> => {
  
  return customFetch<deleteTagResponse>(getDeleteTagUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retourne un taux de change sp√©cifique
 * @summary R√©cup√©rer un taux par son ID
 */
export type getRateByIdResponse200 = {
  data: RateDto
  status: 200
}

export type getRateByIdResponse404 = {
  data: void
  status: 404
}
    
export type getRateByIdResponseSuccess = (getRateByIdResponse200) & {
  headers: Headers;
};
export type getRateByIdResponseError = (getRateByIdResponse404) & {
  headers: Headers;
};

export type getRateByIdResponse = (getRateByIdResponseSuccess | getRateByIdResponseError)

export const getGetRateByIdUrl = (id: number,) => {


  

  return `/rates/${id}`
}

export const getRateById = async (id: number, options?: RequestInit): Promise<getRateByIdResponse> => {
  
  return customFetch<getRateByIdResponse>(getGetRateByIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Met √† jour un taux de change existant
 * @summary Mettre √† jour un taux
 */
export type updateRateResponse200 = {
  data: RateDto
  status: 200
}

export type updateRateResponse400 = {
  data: void
  status: 400
}

export type updateRateResponse404 = {
  data: void
  status: 404
}
    
export type updateRateResponseSuccess = (updateRateResponse200) & {
  headers: Headers;
};
export type updateRateResponseError = (updateRateResponse400 | updateRateResponse404) & {
  headers: Headers;
};

export type updateRateResponse = (updateRateResponseSuccess | updateRateResponseError)

export const getUpdateRateUrl = (id: number,) => {


  

  return `/rates/${id}`
}

export const updateRate = async (id: number,
    rateDto: NonReadonly<RateDto>, options?: RequestInit): Promise<updateRateResponse> => {
  
  return customFetch<updateRateResponse>(getUpdateRateUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      rateDto,)
  }
);}



/**
 * Supprime un taux de change
 * @summary Supprimer un taux
 */
export type deleteRateResponse204 = {
  data: void
  status: 204
}

export type deleteRateResponse404 = {
  data: void
  status: 404
}
    
export type deleteRateResponseSuccess = (deleteRateResponse204) & {
  headers: Headers;
};
export type deleteRateResponseError = (deleteRateResponse404) & {
  headers: Headers;
};

export type deleteRateResponse = (deleteRateResponseSuccess | deleteRateResponseError)

export const getDeleteRateUrl = (id: number,) => {


  

  return `/rates/${id}`
}

export const deleteRate = async (id: number, options?: RequestInit): Promise<deleteRateResponse> => {
  
  return customFetch<deleteRateResponse>(getDeleteRateUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retourne une p√©riode sp√©cifique
 * @summary R√©cup√©rer une p√©riode par son ID
 */
export type getPeriodByIdResponse200 = {
  data: PeriodDto
  status: 200
}

export type getPeriodByIdResponse404 = {
  data: void
  status: 404
}
    
export type getPeriodByIdResponseSuccess = (getPeriodByIdResponse200) & {
  headers: Headers;
};
export type getPeriodByIdResponseError = (getPeriodByIdResponse404) & {
  headers: Headers;
};

export type getPeriodByIdResponse = (getPeriodByIdResponseSuccess | getPeriodByIdResponseError)

export const getGetPeriodByIdUrl = (id: number,) => {


  

  return `/periods/${id}`
}

export const getPeriodById = async (id: number, options?: RequestInit): Promise<getPeriodByIdResponse> => {
  
  return customFetch<getPeriodByIdResponse>(getGetPeriodByIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Met √† jour une p√©riode comptable existante
 * @summary Mettre √† jour une p√©riode
 */
export type updatePeriodResponse200 = {
  data: PeriodDto
  status: 200
}

export type updatePeriodResponse400 = {
  data: void
  status: 400
}

export type updatePeriodResponse404 = {
  data: void
  status: 404
}
    
export type updatePeriodResponseSuccess = (updatePeriodResponse200) & {
  headers: Headers;
};
export type updatePeriodResponseError = (updatePeriodResponse400 | updatePeriodResponse404) & {
  headers: Headers;
};

export type updatePeriodResponse = (updatePeriodResponseSuccess | updatePeriodResponseError)

export const getUpdatePeriodUrl = (id: number,) => {


  

  return `/periods/${id}`
}

export const updatePeriod = async (id: number,
    periodDto: NonReadonly<PeriodDto>, options?: RequestInit): Promise<updatePeriodResponse> => {
  
  return customFetch<updatePeriodResponse>(getUpdatePeriodUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      periodDto,)
  }
);}



/**
 * Supprime une p√©riode comptable
 * @summary Supprimer une p√©riode
 */
export type deletePeriodResponse204 = {
  data: void
  status: 204
}

export type deletePeriodResponse404 = {
  data: void
  status: 404
}
    
export type deletePeriodResponseSuccess = (deletePeriodResponse204) & {
  headers: Headers;
};
export type deletePeriodResponseError = (deletePeriodResponse404) & {
  headers: Headers;
};

export type deletePeriodResponse = (deletePeriodResponseSuccess | deletePeriodResponseError)

export const getDeletePeriodUrl = (id: number,) => {


  

  return `/periods/${id}`
}

export const deletePeriod = async (id: number, options?: RequestInit): Promise<deletePeriodResponse> => {
  
  return customFetch<deletePeriodResponse>(getDeletePeriodUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retourne une entr√©e sp√©cifique identifi√©e par son ID
 * @summary R√©cup√©rer une entr√©e par son ID
 */
export type getEntryByIdResponse200 = {
  data: EntryDto
  status: 200
}

export type getEntryByIdResponse404 = {
  data: void
  status: 404
}
    
export type getEntryByIdResponseSuccess = (getEntryByIdResponse200) & {
  headers: Headers;
};
export type getEntryByIdResponseError = (getEntryByIdResponse404) & {
  headers: Headers;
};

export type getEntryByIdResponse = (getEntryByIdResponseSuccess | getEntryByIdResponseError)

export const getGetEntryByIdUrl = (id: number,) => {


  

  return `/entries/${id}`
}

export const getEntryById = async (id: number, options?: RequestInit): Promise<getEntryByIdResponse> => {
  
  return customFetch<getEntryByIdResponse>(getGetEntryByIdUrl(id),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Met √† jour une entr√©e existante avec les nouvelles informations fournies
 * @summary Mettre √† jour une entr√©e
 */
export type updateEntryResponse200 = {
  data: EntryDto
  status: 200
}

export type updateEntryResponse400 = {
  data: void
  status: 400
}

export type updateEntryResponse404 = {
  data: void
  status: 404
}
    
export type updateEntryResponseSuccess = (updateEntryResponse200) & {
  headers: Headers;
};
export type updateEntryResponseError = (updateEntryResponse400 | updateEntryResponse404) & {
  headers: Headers;
};

export type updateEntryResponse = (updateEntryResponseSuccess | updateEntryResponseError)

export const getUpdateEntryUrl = (id: number,) => {


  

  return `/entries/${id}`
}

export const updateEntry = async (id: number,
    entryDto: NonReadonly<EntryDto>, options?: RequestInit): Promise<updateEntryResponse> => {
  
  return customFetch<updateEntryResponse>(getUpdateEntryUrl(id),
  {      
    ...options,
    method: 'PUT',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      entryDto,)
  }
);}



/**
 * Supprime d√©finitivement une entr√©e existante
 * @summary Supprimer une entr√©e
 */
export type deleteEntryResponse204 = {
  data: void
  status: 204
}

export type deleteEntryResponse404 = {
  data: void
  status: 404
}
    
export type deleteEntryResponseSuccess = (deleteEntryResponse204) & {
  headers: Headers;
};
export type deleteEntryResponseError = (deleteEntryResponse404) & {
  headers: Headers;
};

export type deleteEntryResponse = (deleteEntryResponseSuccess | deleteEntryResponseError)

export const getDeleteEntryUrl = (id: number,) => {


  

  return `/entries/${id}`
}

export const deleteEntry = async (id: number, options?: RequestInit): Promise<deleteEntryResponse> => {
  
  return customFetch<deleteEntryResponse>(getDeleteEntryUrl(id),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}



/**
 * Retourne une liste pagin√©e de tous les tags
 * @summary R√©cup√©rer tous les tags
 */
export type getTagsResponse200 = {
  data: PageImplTagDto
  status: 200
}
    
export type getTagsResponseSuccess = (getTagsResponse200) & {
  headers: Headers;
};
;

export type getTagsResponse = (getTagsResponseSuccess)

export const getGetTagsUrl = (params?: GetTagsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["sort"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/tags?${stringifiedParams}` : `/tags`
}

export const getTags = async (params?: GetTagsParams, options?: RequestInit): Promise<getTagsResponse> => {
  
  return customFetch<getTagsResponse>(getGetTagsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Cr√©e un nouveau tag/√©tiquette
 * @summary Cr√©er un nouveau tag
 */
export type createTagResponse201 = {
  data: TagDto
  status: 201
}

export type createTagResponse400 = {
  data: void
  status: 400
}
    
export type createTagResponseSuccess = (createTagResponse201) & {
  headers: Headers;
};
export type createTagResponseError = (createTagResponse400) & {
  headers: Headers;
};

export type createTagResponse = (createTagResponseSuccess | createTagResponseError)

export const getCreateTagUrl = () => {


  

  return `/tags`
}

export const createTag = async (tagDto: TagDto, options?: RequestInit): Promise<createTagResponse> => {
  
  return customFetch<createTagResponse>(getCreateTagUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      tagDto,)
  }
);}



/**
 * Retourne une liste pagin√©e de tous les taux de change
 * @summary R√©cup√©rer tous les taux de change
 */
export type getRatesResponse200 = {
  data: PageImplRateDto
  status: 200
}
    
export type getRatesResponseSuccess = (getRatesResponse200) & {
  headers: Headers;
};
;

export type getRatesResponse = (getRatesResponseSuccess)

export const getGetRatesUrl = (params?: GetRatesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["sort"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/rates?${stringifiedParams}` : `/rates`
}

export const getRates = async (params?: GetRatesParams, options?: RequestInit): Promise<getRatesResponse> => {
  
  return customFetch<getRatesResponse>(getGetRatesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Cr√©e un nouveau taux de change
 * @summary Cr√©er un nouveau taux
 */
export type createRateResponse201 = {
  data: RateDto
  status: 201
}

export type createRateResponse400 = {
  data: void
  status: 400
}
    
export type createRateResponseSuccess = (createRateResponse201) & {
  headers: Headers;
};
export type createRateResponseError = (createRateResponse400) & {
  headers: Headers;
};

export type createRateResponse = (createRateResponseSuccess | createRateResponseError)

export const getCreateRateUrl = () => {


  

  return `/rates`
}

export const createRate = async (rateDto: NonReadonly<RateDto>, options?: RequestInit): Promise<createRateResponse> => {
  
  return customFetch<createRateResponse>(getCreateRateUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      rateDto,)
  }
);}



/**
 * Retourne une liste pagin√©e de toutes les p√©riodes comptables
 * @summary R√©cup√©rer toutes les p√©riodes
 */
export type getPeriodsResponse200 = {
  data: PageImplPeriodDto
  status: 200
}
    
export type getPeriodsResponseSuccess = (getPeriodsResponse200) & {
  headers: Headers;
};
;

export type getPeriodsResponse = (getPeriodsResponseSuccess)

export const getGetPeriodsUrl = (params?: GetPeriodsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["sort"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/periods?${stringifiedParams}` : `/periods`
}

export const getPeriods = async (params?: GetPeriodsParams, options?: RequestInit): Promise<getPeriodsResponse> => {
  
  return customFetch<getPeriodsResponse>(getGetPeriodsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Cr√©e une nouvelle p√©riode comptable
 * @summary Cr√©er une nouvelle p√©riode
 */
export type createPeriodResponse201 = {
  data: PeriodDto
  status: 201
}

export type createPeriodResponse400 = {
  data: void
  status: 400
}
    
export type createPeriodResponseSuccess = (createPeriodResponse201) & {
  headers: Headers;
};
export type createPeriodResponseError = (createPeriodResponse400) & {
  headers: Headers;
};

export type createPeriodResponse = (createPeriodResponseSuccess | createPeriodResponseError)

export const getCreatePeriodUrl = () => {


  

  return `/periods`
}

export const createPeriod = async (periodDto: NonReadonly<PeriodDto>, options?: RequestInit): Promise<createPeriodResponse> => {
  
  return customFetch<createPeriodResponse>(getCreatePeriodUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      periodDto,)
  }
);}



/**
 * Retourne une liste pagin√©e d'entr√©es filtr√©es selon les crit√®res de recherche fournis
 * @summary R√©cup√©rer toutes les entr√©es
 */
export type getEntriesResponse200 = {
  data: PageImplEntryDto
  status: 200
}
    
export type getEntriesResponseSuccess = (getEntriesResponse200) & {
  headers: Headers;
};
;

export type getEntriesResponse = (getEntriesResponseSuccess)

export const getGetEntriesUrl = (params?: GetEntriesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["tagIds","currencyCodes","sort"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/entries?${stringifiedParams}` : `/entries`
}

export const getEntries = async (params?: GetEntriesParams, options?: RequestInit): Promise<getEntriesResponse> => {
  
  return customFetch<getEntriesResponse>(getGetEntriesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Cr√©e une nouvelle entr√©e financi√®re avec les informations fournies
 * @summary Cr√©er une nouvelle entr√©e
 */
export type createEntryResponse201 = {
  data: EntryDto
  status: 201
}

export type createEntryResponse400 = {
  data: void
  status: 400
}
    
export type createEntryResponseSuccess = (createEntryResponse201) & {
  headers: Headers;
};
export type createEntryResponseError = (createEntryResponse400) & {
  headers: Headers;
};

export type createEntryResponse = (createEntryResponseSuccess | createEntryResponseError)

export const getCreateEntryUrl = () => {


  

  return `/entries`
}

export const createEntry = async (entryDto: NonReadonly<EntryDto>, options?: RequestInit): Promise<createEntryResponse> => {
  
  return customFetch<createEntryResponse>(getCreateEntryUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      entryDto,)
  }
);}



/**
 * Retourne une liste pagin√©e de toutes les devises
 * @summary R√©cup√©rer toutes les devises
 */
export type getCurrenciesResponse200 = {
  data: PageImplCurrencyDto
  status: 200
}
    
export type getCurrenciesResponseSuccess = (getCurrenciesResponse200) & {
  headers: Headers;
};
;

export type getCurrenciesResponse = (getCurrenciesResponseSuccess)

export const getGetCurrenciesUrl = (params?: GetCurrenciesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["sort"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/currencies?${stringifiedParams}` : `/currencies`
}

export const getCurrencies = async (params?: GetCurrenciesParams, options?: RequestInit): Promise<getCurrenciesResponse> => {
  
  return customFetch<getCurrenciesResponse>(getGetCurrenciesUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Cr√©e une nouvelle devise
 * @summary Cr√©er une nouvelle devise
 */
export type createCurrencyResponse201 = {
  data: CurrencyDto
  status: 201
}

export type createCurrencyResponse400 = {
  data: void
  status: 400
}
    
export type createCurrencyResponseSuccess = (createCurrencyResponse201) & {
  headers: Headers;
};
export type createCurrencyResponseError = (createCurrencyResponse400) & {
  headers: Headers;
};

export type createCurrencyResponse = (createCurrencyResponseSuccess | createCurrencyResponseError)

export const getCreateCurrencyUrl = () => {


  

  return `/currencies`
}

export const createCurrency = async (currencyDto: CurrencyDto, options?: RequestInit): Promise<createCurrencyResponse> => {
  
  return customFetch<createCurrencyResponse>(getCreateCurrencyUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      currencyDto,)
  }
);}



/**
 * Calcule la somme des montants fournis en appliquant les taux de change appropri√©s pour convertir dans la devise cible
 * @summary Calculer la somme avec conversion de devises
 */
export type computeResponse200 = {
  data: ComputationResponseDto
  status: 200
}

export type computeResponse400 = {
  data: void
  status: 400
}
    
export type computeResponseSuccess = (computeResponse200) & {
  headers: Headers;
};
export type computeResponseError = (computeResponse400) & {
  headers: Headers;
};

export type computeResponse = (computeResponseSuccess | computeResponseError)

export const getComputeUrl = () => {


  

  return `/computation`
}

export const compute = async (computationRequestDto: ComputationRequestDto, options?: RequestInit): Promise<computeResponse> => {
  
  return customFetch<computeResponse>(getComputeUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      computationRequestDto,)
  }
);}



/**
 * Retourne les taux de change pour une devise sp√©cifique
 * @summary R√©cup√©rer les taux par devise
 */
export type getRatesByCurrencyResponse200 = {
  data: RateDto[]
  status: 200
}
    
export type getRatesByCurrencyResponseSuccess = (getRatesByCurrencyResponse200) & {
  headers: Headers;
};
;

export type getRatesByCurrencyResponse = (getRatesByCurrencyResponseSuccess)

export const getGetRatesByCurrencyUrl = (currencyCode: string,
    params?: GetRatesByCurrencyParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    const explodeParameters = ["sort"];

    if (Array.isArray(value) && explodeParameters.includes(key)) {
      value.forEach((v) => {
        normalizedParams.append(key, v === null ? 'null' : v.toString());
      });
      return;
    }
      
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/rates/currency/${currencyCode}?${stringifiedParams}` : `/rates/currency/${currencyCode}`
}

export const getRatesByCurrency = async (currencyCode: string,
    params?: GetRatesByCurrencyParams, options?: RequestInit): Promise<getRatesByCurrencyResponse> => {
  
  return customFetch<getRatesByCurrencyResponse>(getGetRatesByCurrencyUrl(currencyCode,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retourne la p√©riode comptable contenant une date sp√©cifique
 * @summary R√©cup√©rer une p√©riode par date
 */
export type getPeriodByDateResponse200 = {
  data: PeriodDto
  status: 200
}

export type getPeriodByDateResponse404 = {
  data: void
  status: 404
}
    
export type getPeriodByDateResponseSuccess = (getPeriodByDateResponse200) & {
  headers: Headers;
};
export type getPeriodByDateResponseError = (getPeriodByDateResponse404) & {
  headers: Headers;
};

export type getPeriodByDateResponse = (getPeriodByDateResponseSuccess | getPeriodByDateResponseError)

export const getGetPeriodByDateUrl = (params: GetPeriodByDateParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/periods/by-date?${stringifiedParams}` : `/periods/by-date`
}

export const getPeriodByDate = async (params: GetPeriodByDateParams, options?: RequestInit): Promise<getPeriodByDateResponse> => {
  
  return customFetch<getPeriodByDateResponse>(getGetPeriodByDateUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Retourne une devise sp√©cifique identifi√©e par son code ISO
 * @summary R√©cup√©rer une devise par son code
 */
export type getCurrencyByCodeResponse200 = {
  data: CurrencyDto
  status: 200
}

export type getCurrencyByCodeResponse404 = {
  data: void
  status: 404
}
    
export type getCurrencyByCodeResponseSuccess = (getCurrencyByCodeResponse200) & {
  headers: Headers;
};
export type getCurrencyByCodeResponseError = (getCurrencyByCodeResponse404) & {
  headers: Headers;
};

export type getCurrencyByCodeResponse = (getCurrencyByCodeResponseSuccess | getCurrencyByCodeResponseError)

export const getGetCurrencyByCodeUrl = (code: string,) => {


  

  return `/currencies/${code}`
}

export const getCurrencyByCode = async (code: string, options?: RequestInit): Promise<getCurrencyByCodeResponse> => {
  
  return customFetch<getCurrencyByCodeResponse>(getGetCurrencyByCodeUrl(code),
  {      
    ...options,
    method: 'GET'
    
    
  }
);}



/**
 * Supprime une devise
 * @summary Supprimer une devise
 */
export type deleteCurrencyResponse204 = {
  data: void
  status: 204
}

export type deleteCurrencyResponse404 = {
  data: void
  status: 404
}
    
export type deleteCurrencyResponseSuccess = (deleteCurrencyResponse204) & {
  headers: Headers;
};
export type deleteCurrencyResponseError = (deleteCurrencyResponse404) & {
  headers: Headers;
};

export type deleteCurrencyResponse = (deleteCurrencyResponseSuccess | deleteCurrencyResponseError)

export const getDeleteCurrencyUrl = (code: string,) => {


  

  return `/currencies/${code}`
}

export const deleteCurrency = async (code: string, options?: RequestInit): Promise<deleteCurrencyResponse> => {
  
  return customFetch<deleteCurrencyResponse>(getDeleteCurrencyUrl(code),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
);}
